<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <script src="js/jquery.min.js"></script>

    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PengJiuYue's Photos</title>
    <link rel="stylesheet" type="text/css" href="css/shuffling/normalize.css" />
    <link rel="stylesheet" type="text/css" href="css/shuffling/default.css" />
    <link
      rel="stylesheet"
      type="text/css"
      href="css/shuffling/animate.min.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="css/shuffling/crosscover.min.css"
    />
    <style type="text/css">
      html {
        overflow: hidden;

        -ms-touch-action: none;

        -ms-content-zooming: none;
      }

      body {
        position: absolute;

        margin: 0px;

        padding: 0px;

        background: #e0e0e0;

        width: 100%;

        height: 100%;
      }

      .open_effect {
        width: 60px;
        height: 30px;
        position: absolute;
        right: 40px;
        bottom: 100px;
      }

      .background_container {
        position: absolute;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        background-position: center center;
        background-repeat: no-repeat;
        background-size: cover;
        background-color: #000000;
        opacity: 1;
      }

      .cherry_container {
        position: absolute;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
        background-position: center center;
        background-repeat: no-repeat;
        background-size: cover;
        background-color: #000000;
        opacity: 1;
      }
      #sakura {
        position: absolute;

        width: 100%;

        height: 100%;

        /* background: #e0e0e0; */
        /* background-image: url("https://www.helloimg.com/i/2024/09/12/66e265ce8496b.png"); */
      }
      #canvas {
        position: absolute;

        width: 100%;

        height: 100%;

        /* background: #e0e0e0; */
        /* background-image: url("https://www.helloimg.com/i/2024/09/12/66e265ce8496b.png"); */
      }
      .canvas {
        position: absolute;
        width: 100%;
        top:-200px;
        height: 90%;

        /* background: #e0e0e0; */
        /* background-image: url("https://www.helloimg.com/i/2024/09/12/66e265ce8496b.png"); */
      }
      #sbtn {
        width: 50px;
        position: fixed;
        right: 60px;
        bottom: 60px;
      }
      #sbtn:hover {
        width: 60px;
        position: fixed;
        right: 60px;
        bottom: 60px;
      }

      input[type="checkbox"].switch {
        outline: none;
        appearance: none;
        -webkit-appearance: none;
        -moz-appearance: none;
        position: relative;
        width: 40px;
        height: 20px;
        background: #ccc;
        border-radius: 10px;
        transition: border-color 0.3s, background-color 0.3s;
      }

      input[type="checkbox"].switch::after {
        content: "";
        display: inline-block;
        width: 1rem;
        height: 1rem;
        border-radius: 50%;
        background: #fff;
        box-shadow: 0, 0, 2px, #999;
        transition: 0.4s;
        top: 2px;
        position: absolute;
        left: 2px;
      }

      input[type="checkbox"].switch:checked {
        background: rgb(19, 206, 102);
      }
      /* 当input[type=checkbox]被选中时：伪元素显示下面样式 位置发生变化 */
      input[type="checkbox"].switch:checked::after {
        content: "";
        position: absolute;
        left: 55%;
        top: 2px;
      }
    </style>

    <script type="text/javascript" src="js/ge1doot.js"></script>

    <script type="text/javascript">
      "use strict";

      Array.prototype.indexOf = function (val) {
        for (var i = 0; i < this.length; i++) {
          if (this[i] == val) return i;
        }
        return -1;
      };
      var picgroup = [
        "https://i.postimg.cc/3Rpbf0cm/29.jpg",
        // 1-10
        "https://i.postimg.cc/Dyqn48fW/1.jpg",
        "https://i.postimg.cc/fydZKbxr/2.jpg",
        "https://i.postimg.cc/28pC54YR/3.jpg",
        "https://i.postimg.cc/PfvthSBQ/4.jpg",
        "https://i.postimg.cc/XY43f4Xs/5.jpg",
        "https://i.postimg.cc/52gJpTCb/6.jpg",
        "https://i.postimg.cc/mrrsnjYM/7.jpg",
        "https://i.postimg.cc/90y59n23/8.jpg",
        "https://i.postimg.cc/GpSCnDKf/9.jpg",
        "https://i.postimg.cc/Qt9r8Mnd/10.jpg",

        // 11-20
        "https://i.postimg.cc/FRMX7Q2g/11.jpg",
        "https://i.postimg.cc/J7XWSGkT/12.jpg",
        "https://i.postimg.cc/ZKhhm4PJ/13.jpg",
        "https://i.postimg.cc/gkqbkQ48/14.jpg",
        "https://i.postimg.cc/4xfkKPFM/15.jpg",
        "https://i.postimg.cc/Z5wk6NGq/16.jpg",
        "https://i.postimg.cc/ZqnGHRmx/17.jpg",
        "https://i.postimg.cc/tgcLMjCQ/18.jpg",
        "https://i.postimg.cc/KjPwj37x/19.jpg",
        "https://i.postimg.cc/KjSCmDM0/20.jpg",
        
        // 21-30
        "https://i.postimg.cc/bJ2KXBsG/21.jpg",
        "https://i.postimg.cc/SQCwD3B3/22.jpg",
        "https://i.postimg.cc/HsmFK3Hx/23.jpg",
        "https://i.postimg.cc/02Chqm2C/24.jpg",
        "https://i.postimg.cc/DwjDSTGJ/25.jpg",
        "https://i.postimg.cc/y8Yt6dDC/26.jpg",
        "https://i.postimg.cc/BvRVCBMJ/27.jpg",
        "https://i.postimg.cc/HLrN5h0S/28.jpg",
        
      ];
      var full_img_group = [
        // 1-10
        "https://i.postimg.cc/Dyqn48fW/1.jpg",
        "https://i.postimg.cc/fydZKbxr/2.jpg",
        "https://i.postimg.cc/28pC54YR/3.jpg",
        "https://i.postimg.cc/PfvthSBQ/4.jpg",
        "https://i.postimg.cc/XY43f4Xs/5.jpg",
        "https://i.postimg.cc/52gJpTCb/6.jpg",
        "https://i.postimg.cc/mrrsnjYM/7.jpg",
        "https://i.postimg.cc/90y59n23/8.jpg",
        "https://i.postimg.cc/GpSCnDKf/9.jpg",
        "https://i.postimg.cc/Qt9r8Mnd/10.jpg",

        // 11-20
        "https://i.postimg.cc/FRMX7Q2g/11.jpg",
        "https://i.postimg.cc/J7XWSGkT/12.jpg",
        "https://i.postimg.cc/ZKhhm4PJ/13.jpg",
        "https://i.postimg.cc/gkqbkQ48/14.jpg",
        "https://i.postimg.cc/4xfkKPFM/15.jpg",
        "https://i.postimg.cc/Z5wk6NGq/16.jpg",
        "https://i.postimg.cc/ZqnGHRmx/17.jpg",
        "https://i.postimg.cc/tgcLMjCQ/18.jpg",
        "https://i.postimg.cc/KjPwj37x/19.jpg",
        "https://i.postimg.cc/KjSCmDM0/20.jpg",
        
        // 21-30
        "https://i.postimg.cc/bJ2KXBsG/21.jpg",
        "https://i.postimg.cc/SQCwD3B3/22.jpg",
        "https://i.postimg.cc/HsmFK3Hx/23.jpg",
        "https://i.postimg.cc/02Chqm2C/24.jpg",
        "https://i.postimg.cc/DwjDSTGJ/25.jpg",
        "https://i.postimg.cc/y8Yt6dDC/26.jpg",
        "https://i.postimg.cc/BvRVCBMJ/27.jpg",
        "https://i.postimg.cc/HLrN5h0S/28.jpg",
        "",
      ];
      /* ============ init pictures start ============ */
      // 图片数量 picnum大于等于8，并且可以被4整除
      let picnum = 28;
      // 视频数量 vedionum需要小于picnum
      let vedionum = 0;
      // 是否开启轮播 开启true 关闭 false
      let enableShuffling = true;

      picnum = Math.floor(picnum / 4) * 4;
      let median = (picnum - 6) / 2;
      let imgdataArray = new Array();

      // 加载图片
      for (let i = 1; i <= picnum; i++) {
        // north 北墙
        if (i <= median) {
          if (i == 1) {
            imgdataArray[i - 1] = {
              img: picgroup[i],
              x: 0,
              y: 0,
              z: 1500,
              nx: 0,
              nz: 1,
            };
          } else {
            imgdataArray[i - 1] = {
              img: picgroup[i],
              x: (i / 2) * -1000,
              y: 0,
              z: 1500,
              nx: 0,
              nz: 1,
            };
            i++;
            imgdataArray[i - 1] = {
              img: picgroup[i],
              x: ((i - 1) / 2) * 1000,
              y: 0,
              z: 1500,
              nx: 0,
              nz: 1,
            };
          }
        }
        // south 南墙
        else if (i > median && i <= picnum - 6) {
          if (i == median + 1) {
            imgdataArray[i - 1] = {
              img: picgroup[i],
              x: 0,
              y: 0,
              z: -1500,
              nx: 0,
              nz: -1,
            };
          } else {
            imgdataArray[i - 1] = {
              img: picgroup[i],
              x: ((i - median) / 2) * -1000,
              y: 0,
              z: -1500,
              nx: 0,
              nz: -1,
            };
            i++;
            imgdataArray[i - 1] = {
              img: picgroup[i],
              x: ((i - median - 1) / 2) * 1000,
              y: 0,
              z: -1500,
              nx: 0,
              nz: -1,
            };
          }
        }
        // east 东墙
        else if (i > picnum - 6 && i <= picnum - 3) {
          imgdataArray[i - 1] = {
            img: picgroup[i],
            x: ((median - 1) / 2) * 1000 + (enableShuffling ? 1500 : 500),
            y: 0,
            z: 1000 * (picnum - i - 4),
            nx: -1,
            nz: 0,
          };
        }
        // west 西墙
        else {
          imgdataArray[i - 1] = {
            img: picgroup[i],
            x: ((median - 1) / 2) * -1000 - (enableShuffling ? 1500 : 500),
            y: 0,
            z: 1000 * (picnum - i - 1),
            nx: 1,
            nz: 0,
          };
        }
      }

      if (enableShuffling) {
        imgdataArray[picnum] = {
          img: picgroup[0],
          x: ((median - 1) / 2) * 1000 + 1000,
          y: 0,
          z: 1500,
          nx: 0,
          nz: 1,
        };
        imgdataArray[picnum + 1] = {
          img: picgroup[0],
          x: ((median - 1) / 2) * -1000 - 1000,
          y: 0,
          z: 1500,
          nx: 0,
          nz: 1,
        };
        imgdataArray[picnum + 2] = {
          img: picgroup[0],
          x: ((median - 1) / 2) * 1000 + 1000,
          y: 0,
          z: -1500,
          nx: 0,
          nz: -1,
        };
        imgdataArray[picnum + 3] = {
          img: picgroup[0],
          x: ((median - 1) / 2) * -1000 - 1000,
          y: 0,
          z: -1500,
          nx: 0,
          nz: -1,
        };
      }

      // 加载视频，生成随机数，并在imgdataArray中进行替换
      for (let i = 301; i <= 300 + vedionum; i++) {
        let index = parseInt(
          Math.ceil(Math.random() * (enableShuffling ? picnum - 4 : picnum))
        );
        imgdataArray[index].img = picgroup[i];
      }

      /* ============ init pictures end ============ */

      (function () {
        /* ==== definitions ==== */

        var diapo = [],
          layers = [],
          ctx,
          pointer,
          scr,
          camera,
          light,
          fps = 0,
          quality = [1, 2],
          imageData,
          num_of_images,
          // ---- poly constructor ----

          Poly = function (parent, face) {
            this.parent = parent;

            this.ctx = ctx;

            this.color = face.fill || false;

            this.points = [];

            if (!face.img) {
              // ---- create points ----

              for (var i = 0; i < 4; i++) {
                this.points[i] = new ge1doot.transform3D.Point(
                  parent.pc.x +
                    face.x[i] * parent.normalZ +
                    face.z[i] * parent.normalX,

                  parent.pc.y + face.y[i],

                  parent.pc.z +
                    face.x[i] * parent.normalX +
                    -face.z[i] * parent.normalZ
                );
              }

              this.points[3].next = false;
            }
          },
          // ---- diapo constructor ----  将每一张图片都封装成一个对象

          Diapo = function (path, img, structure) {
            // ---- create image ----

            this.img = new ge1doot.transform3D.Image(this, path + img.img, 1, {
              isLoaded: function (img) {
                img.parent.isLoaded = true;

                img.parent.loaded(img);
              },
            });
            console.log(JSON.stringify(img));
            this.visible = false;

            this.normalX = img.nx;

            this.normalZ = img.nz;

            // ---- point center ----

            this.pc = new ge1doot.transform3D.Point(img.x, img.y, img.z);

            // ---- target positions ----

            this.tx = img.x + img.nx * Math.sqrt(camera.focalLength) * 20;

            this.tz = img.z - img.nz * Math.sqrt(camera.focalLength) * 20;

            // ---- create polygons ----

            this.poly = [];

            for (var i = -1, p; (p = structure[++i]); ) {
              layers[i] = p.img === true ? 1 : 2;

              this.poly.push(new Poly(this, p));
            }
          },
          // ---- init section ----

          init = function (json) {
            // draw poly primitive

            Poly.prototype.drawPoly = ge1doot.transform3D.drawPoly;

            // ---- init screen ----

            scr = new ge1doot.Screen({
              container: "canvas",
            });

            ctx = scr.ctx;

            scr.resize();

            // ---- init pointer ----

            pointer = new ge1doot.Pointer({
              tap: function () {
                if (camera.over) {
                  // 控制摄像头运动

                  if (camera.over === camera.target.elem) {
                    //alert(camera.target.z);
                    enter_fullScreen_or_video(
                      imageData,
                      camera.target.x,
                      camera.target.z,
                      num_of_images
                    ); // 再次点击时，调用该函数
                    // ---- return to the center ----
                    var cameraX_abs = Math.abs(camera.target.x); // 得到当前x的绝对值
                    var threshold = (((num_of_images - 6) / 2 - 1) / 2) * 1000; // 获取阙值
                    if (cameraX_abs <= threshold) {
                      camera.target.x = camera.target.x; // 再次点击时，垂直往后退
                      camera.target.z = 0;
                    } else {
                      if (camera.target.x < 0) {
                        camera.target.x = camera.target.x + 1000;
                        camera.target.z = camera.target.z;
                      } else {
                        camera.target.x = camera.target.x - 1000;
                        camera.target.z = camera.target.z;
                      }
                    }

                    camera.target.elem = false;
                  } else {
                    // ---- goto diapo ----

                    camera.target.elem = camera.over;

                    camera.target.x = camera.over.tx;

                    camera.target.z = camera.over.tz;

                    // ---- adapt tesselation level to distance ----  使镶嵌化水平适应距离

                    for (var i = 0, d; (d = diapo[i++]); ) {
                      var dx = camera.target.x - d.pc.x;

                      var dz = camera.target.z - d.pc.z;

                      var dist = Math.sqrt(dx * dx + dz * dz);

                      var lev = dist > 1500 ? quality[0] : quality[1];

                      d.img.setLevel(lev);
                    }
                  }
                }
              },
            });

            // ---- init camera ----

            camera = new ge1doot.transform3D.Camera(
              {
                focalLength: Math.sqrt(scr.width) * 10,

                easeTranslation: 0.025,

                easeRotation: 0.06,

                disableRz: true,
              },
              {
                move: function () {
                  // 摄像头运动函数

                  this.over = false;

                  // ---- rotation ----  摄像头可以3D旋转

                  if (pointer.isDraging) {
                    this.target.elem = false;

                    this.target.ry = -pointer.Xi * 0.01;

                    this.target.rx =
                      (pointer.Y - scr.height * 0.5) / (scr.height * 0.5);
                  } else {
                    if (this.target.elem) {
                      this.target.ry = Math.atan2(
                        this.target.elem.pc.x - this.x,

                        this.target.elem.pc.z - this.z
                      );
                    }
                  }

                  this.target.rx *= 0.9;
                },
              }
            );

            camera.z = -10000;

            camera.py = 0;

            // ---- create images ----  创建图片对象

            for (var i = 0, img; (img = json.imgdata[i++]); ) {
              num_of_images = i;

              diapo.push(
                new Diapo(
                  json.options.imagesPath,

                  img,

                  json.structure
                )
              );
            }

            // ---- start engine ---- >>>

            setInterval(function () {
              quality = fps > 50 ? [2, 3] : [1, 2];

              fps = 0;
            }, 1000);

            run();
          },
          // ---- main loop ----

          run = function () {
            // ---- clear screen ----

            ctx.clearRect(0, 0, scr.width, scr.height);

            // ---- camera ----

            camera.move();

            // ---- draw layers ----  画层

            for (var k = -1, l; (l = layers[++k]); ) {
              light = false;

              for (var i = 0, d; (d = diapo[i++]); ) {
                (l === 1 && d.draw()) || (d.visible && d.poly[k].draw());
              }
            }

            // ---- cursor ----

            if (camera.over && !pointer.isDraging) {
              scr.setCursor("pointer"); // 鼠标点中图片，游标为pointer
            } else {
              scr.setCursor("move"); // camera移动时，游标为move
            }

            // ---- loop ----

            fps++;

            requestAnimFrame(run);
          };

        /* ==== prototypes原型 ==== */

        Poly.prototype.draw = function () {
          // ---- color light ----

          var c = this.color;

          if (c.light || !light) {
            var s = c.light ? this.parent.light : 1;

            // ---- rgba color ----  控制墙是否透明

            light =
              "rgba(" +
              Math.round(c.r * s) +
              "," +
              Math.round(c.g * s) +
              "," +
              Math.round(c.b * s) +
              "," +
              (c.a || 1) +
              ")";

            ctx.fillStyle = light;
          }

          // ---- paint poly ----

          if (!c.light || this.parent.light < 1) {
            // ---- projection ----

            for (var i = 0; this.points[i++].projection(); );

            this.drawPoly();

            ctx.fill();
          }
        };

        /* ==== image onload ==== */

        Diapo.prototype.loaded = function (img) {
          // ---- create points ---- 初始化时，各个图片的长宽

          var d = [-1, 1, 1, -1, 1, 1, -1, -1];

          // var w = img.texture.width  * 0.5;

          // var h = img.texture.height * 0.5;
          var w = 320; // 强制确定图片的大小
          var h = 193;

          for (var i = 0; i < 4; i++) {
            img.points[i] = new ge1doot.transform3D.Point(
              this.pc.x + w * this.normalZ * d[i],

              this.pc.y + h * d[i + 4],

              this.pc.z + w * this.normalX * d[i]
            );
          }
        };

        /* ==== images draw 在画板中画出图片==== */

        Diapo.prototype.draw = function () {
          // ---- visibility ----

          this.pc.projection();

          if (
            this.pc.Z > -(camera.focalLength >> 1) &&
            this.img.transform3D(true)
          ) {
            // ---- light ----

            this.light =
              0.5 +
              Math.abs(
                this.normalZ * camera.cosY - this.normalX * camera.sinY
              ) *
                0.6;

            // ---- draw image ----

            this.visible = true;

            this.img.draw();

            // ---- test pointer inside ----

            if (pointer.hasMoved || pointer.isDown) {
              if (
                this.img.isPointerInside(
                  pointer.X,

                  pointer.Y
                )
              )
                camera.over = this;
            }
          } else this.visible = false;

          return true;
        };

        return {
          // --- load data ----  监听事件，在页面加载时，开始执行load函数，载入数据(图片，墙壁，灯，阴影)
          // 最先执行，在页面加载过程中
          load: function (data) {
            imageData = data.imgdata;
            window.addEventListener(
              "load",
              function () {
                ge1doot.loadJS(
                  "js/imageTransform3D.js",

                  init,
                  data
                );
              },
              false
            );
          },
        };
      })().load({
        imgdata: imgdataArray,

        structure: [
          {
            // wall

            fill: { r: 224, g: 224, b: 224, light: 1 },

            x: [-1001, -490, -490, -1001],

            z: [-500, -500, -500, -500],

            y: [500, 500, -500, -500], // 调整墙面的高
          },
          {
            // wall

            fill: { r: 224, g: 224, b: 224, light: 1 },

            x: [-501, 2, 2, -500],

            z: [-500, -500, -500, -500],

            y: [500, 500, -500, -500], // 调整墙面的高
          },
          {
            // wall

            fill: { r: 224, g: 224, b: 224, light: 1 },

            x: [0, 502, 502, 0],

            z: [-500, -500, -500, -500],

            y: [500, 500, -500, -500], // 调整墙面的高
          },
          {
            // wall

            fill: { r: 224, g: 224, b: 224, light: 1 },

            x: [490, 1002, 1002, 490],

            z: [-500, -500, -500, -500],

            y: [500, 500, -500, -500], // 调整墙面的高
          },
          {
            // shadow

            fill: { r: 0, g: 0, b: 0, a: 0.2 },

            x: [-420, 420, 420, -420],

            z: [-500, -500, -500, -500],

            y: [150, 150, -320, -320],
          },
          {
            // shadow

            fill: { r: 0, g: 0, b: 0, a: 0.2 },

            x: [-20, 20, 20, -20],

            z: [-500, -500, -500, -500],

            y: [250, 250, 150, 150],
          },
          {
            // shadow

            fill: { r: 0, g: 0, b: 0, a: 0.2 },

            x: [-20, 20, 20, -20],

            z: [-500, -500, -500, -500],

            y: [-320, -320, -500, -500],
          },
          {
            // shadow

            fill: { r: 0, g: 0, b: 0, a: 0.2 },

            x: [-20, 20, 10, -10],

            z: [-500, -500, -100, -100],

            y: [-500, -500, -500, -500],
          },
          {
            // base

            fill: { r: 128, g: 128, b: 128 },

            x: [-50, 50, 50, -50],

            z: [-150, -150, -50, -50],

            y: [-500, -500, -500, -500],
          },
          {
            // support

            fill: { r: 128, g: 128, b: 128 },

            x: [-10, 10, 10, -10],

            z: [-100, -100, -100, -100],

            y: [300, 300, -500, -500],
          },
          {
            // frame

            fill: { r: 128, g: 128, b: 128 },

            x: [-320, -320, -320, -320],

            z: [0, -20, -20, 0],

            y: [-190, -190, 190, 190],
          },
          {
            // frame

            fill: { r: 128, g: 128, b: 128 },

            x: [320, 320, 320, 320],

            z: [0, -20, -20, 0],

            y: [-190, -190, 190, 190],
          },

          { img: true },

          // {
          //   // ceilingLight

          //   fill: { r: 255, g: 128, b: 0 },

          //   x: [-50, 50, 50, -50],

          //   z: [450, 450, 550, 550],

          //   y: [500, 500, 500, 500],
          // },
          // {
          //   // groundLight

          //   fill: { r: 255, g: 128, b: 0 },

          //   x: [-50, 50, 50, -50],

          //   z: [450, 450, 550, 550],

          //   y: [-500, -500, -500, -500],
          // },
        ],

        options: {
          imagesPath: "",
        },
      });
      function enter_fullScreen_or_video(
        imageData,
        cameraX,
        cameraZ,
        num_of_images
      ) {
        imageData = JSON.stringify(imageData);
        //alert(imageData);
        console.log(imageData);

        var cameraX_abs = Math.abs(cameraX); // 获取绝对值
        var threshold = (((num_of_images - 6) / 2 - 1) / 2) * 1000; // 获取阙值，判断点击的是南北墙还是东西墙

        if (cameraX_abs <= threshold) {
          if (cameraZ < 0) cameraZ = -1500;
          else cameraZ = 1500;
        } else {
          if (cameraX < 0) cameraX = -(threshold + 500);
          else cameraX = threshold + 500;
        }

        var imgname = ""; //存储图片

        var d1 = JSON.parse(imageData); //转换成数组

        d1.forEach(function (t) {
          console.log(t.x + ":" + cameraX + "     " + t.z + ":" + cameraZ);

          if (t.x == cameraX && t.z == cameraZ) {
            imgname = picgroup.indexOf(t.img);

            console.log(imgname + "查找到：" + t.img);
          }
          //console.log(t);
        });

        var data = "";
        var checkbox_state;
        //alert(imgname)
        if (String(imgname) == "0") {
          document.getElementById("shuffle").style.display = "block";
        } else {
          var video_or_full_pic = imgname;
          if (video_or_full_pic < 300) {
            // 图片名小于300的，进入带落樱的全屏模式，否则进入视频模式
            //data= "<img src='full_screen_images/" + imgname +".jpg' style='width:100%; height:auto;' />";

            // 开关显示
            document.getElementById("control_effect").style.display = "block";
            checkbox_state = $("#checkbox_id").is(":checked");
            if (checkbox_state == false) {
              // 落樱效果
              $("#jsi-cherry-container").css(
                "background-image",
                "url(" + full_img_group[Number(imgname) - 1] + ")"
              );
              var cherry_block1 = document.getElementById(
                "jsi-cherry-container"
              );
              cherry_block1.style.display = "block";
            } else {
              // 无落樱效果
              $("#background-container").css(
                "background-image",
                "url(" + full_img_group[Number(imgname) - 1] + ")"
              );
              document.getElementById("background-container").style.display =
                "block";
            }
          } else {
            data =
              "<video loop='loop' autoplay='autoplay' width='100%'>" +
              "<source src='full_screen_videos/" +
              imgname +
              ".webm' type='video/webm'/>" +
              "</video>";
            document.getElementById("cover").innerHTML = data;
          }
        }

        var control_none1 = document.getElementById("control");
        control_none1.style.display = "none";

        document.getElementById("checkbox_id").onclick = () => {
          checkbox_state = $("#checkbox_id").is(":checked");
          if (checkbox_state == false) {
            // 落樱效果
            $("#jsi-cherry-container").css(
              "background-image",
              "url(" + full_img_group[Number(imgname) - 1] + ")"
            );
            var cherry_block1 = document.getElementById("jsi-cherry-container");
            cherry_block1.style.display = "block";
            document.getElementById("background-container").style.display =
              "none";
          } else {
            // 无落樱效果
            var cherry_none1 = document.getElementById("jsi-cherry-container");
            cherry_none1.style.display = "none";
            $("#background-container").css(
              "background-image",
              "url(" + full_img_group[Number(imgname) - 1] + ")"
            );
            document.getElementById("background-container").style.display =
              "block";
          }
        };

        document.getElementById("sbtn").onclick = () => {
          var control_block1 = document.getElementById("control");
          control_block1.style.display = "block";
          if (String(imgname) == "0") {
            document.getElementById("shuffle").style.display = "none";
          } else {
            if (imgname < 300) {
              var cherry_none1 = document.getElementById(
                "jsi-cherry-container"
              );
              cherry_none1.style.display = "none";
              document.getElementById("control_effect").style.display = "none";
              document.getElementById("background-container").style.display =
                "none";
            } else {
              document.getElementById("cover").innerHTML = "";
            }
          }
        };
      }
    </script>

    <link rel="stylesheet" href="sakura/normalize.min.css" />
    <link rel="stylesheet" href="sakura/style.css" />
    <script src="sakura/prefixfree.min.js"></script>

    <link rel="stylesheet" href="title/css/normalize.css">

    <link rel="stylesheet" href="title/css/style.css" media="screen" type="text/css" />
  </head>

  <body>
    <canvas id="sakura"></canvas>
    <canvas class="canvas"></canvas>
    
    <!-- 装视频的div -->
    <div id="cover"></div>

    <!-- 装落樱以及背景的div -->
    <div
      id="jsi-cherry-container"
      class="cherry_container"
      style="display: none"
    ></div>
    <!-- 无落樱单背景的div -->
    <div
      id="background-container"
      class="background_container"
      style="display: none"
    ></div>

    <!-- 轮播div -->
    <div id="shuffle" class="crosscover" style="display: none"></div>

    <!-- 3D空间div -->
    <div id="control">
      <canvas id="canvas"
        >你的浏览器不支持HTML5画布技术,请使用谷歌浏览器。</canvas
      >
    </div>

    <!-- 樱花特效开关 -->
    <div id="control_effect" class="open_effect" style="display: none">
      <div id="control_button">
        <input id="checkbox_id" type="checkbox" class="switch" />
      </div>
    </div>
    <!-- 右下角按钮 -->
    <!-- <div ></div> -->
    <img id="sbtn" src="./icon/back.png" />

    <!-- sakura -->
    <!-- partial:index.partial.html -->
    <!-- <div class="btnbg">
      <button type="button" onclick="toggleAnimation(this)">Stop</button>
    </div> -->

    <!-- sakura shader -->
    <script id="sakura_point_vsh" type="x-shader/x_vertex">
      uniform mat4 uProjection;
      uniform mat4 uModelview;
      uniform vec3 uResolution;
      uniform vec3 uOffset;
      uniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius
      uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start

      attribute vec3 aPosition;
      attribute vec3 aEuler;
      attribute vec2 aMisc; //x:size, y:fade

      varying vec3 pposition;
      varying float psize;
      varying float palpha;
      varying float pdist;

      //varying mat3 rotMat;
      varying vec3 normX;
      varying vec3 normY;
      varying vec3 normZ;
      varying vec3 normal;

      varying float diffuse;
      varying float specular;
      varying float rstop;
      varying float distancefade;

      void main(void) {
          // Projection is based on vertical angle
          vec4 pos = uModelview * vec4(aPosition + uOffset, 1.0);
          gl_Position = uProjection * pos;
          gl_PointSize = aMisc.x * uProjection[1][1] / -pos.z * uResolution.y * 0.5;

          pposition = pos.xyz;
          psize = aMisc.x;
          pdist = length(pos.xyz);
          palpha = smoothstep(0.0, 1.0, (pdist - 0.1) / uFade.z);

          vec3 elrsn = sin(aEuler);
          vec3 elrcs = cos(aEuler);
          mat3 rotx = mat3(
              1.0, 0.0, 0.0,
              0.0, elrcs.x, elrsn.x,
              0.0, -elrsn.x, elrcs.x
          );
          mat3 roty = mat3(
              elrcs.y, 0.0, -elrsn.y,
              0.0, 1.0, 0.0,
              elrsn.y, 0.0, elrcs.y
          );
          mat3 rotz = mat3(
              elrcs.z, elrsn.z, 0.0,
              -elrsn.z, elrcs.z, 0.0,
              0.0, 0.0, 1.0
          );
          mat3 rotmat = rotx * roty * rotz;
          normal = rotmat[2];

          mat3 trrotm = mat3(
              rotmat[0][0], rotmat[1][0], rotmat[2][0],
              rotmat[0][1], rotmat[1][1], rotmat[2][1],
              rotmat[0][2], rotmat[1][2], rotmat[2][2]
          );
          normX = trrotm[0];
          normY = trrotm[1];
          normZ = trrotm[2];

          const vec3 lit = vec3(0.6917144638660746, 0.6917144638660746, -0.20751433915982237);

          float tmpdfs = dot(lit, normal);
          if(tmpdfs < 0.0) {
              normal = -normal;
              tmpdfs = dot(lit, normal);
          }
          diffuse = 0.4 + tmpdfs;

          vec3 eyev = normalize(-pos.xyz);
          if(dot(eyev, normal) > 0.0) {
              vec3 hv = normalize(eyev + lit);
              specular = pow(max(dot(hv, normal), 0.0), 20.0);
          }
          else {
              specular = 0.0;
          }

          rstop = clamp((abs(pdist - uDOF.x) - uDOF.y) / uDOF.z, 0.0, 1.0);
          rstop = pow(rstop, 0.5);
          //-0.69315 = ln(0.5)
          distancefade = min(1.0, exp((uFade.x - pdist) * 0.69315 / uFade.y));
      }
    </script>
    <script id="sakura_point_fsh" type="x-shader/x_fragment">
      #ifdef GL_ES
      //precision mediump float;
      precision highp float;
      #endif

      uniform vec3 uDOF;  //x:focus distance, y:focus radius, z:max radius
      uniform vec3 uFade; //x:start distance, y:half distance, z:near fade start

      const vec3 fadeCol = vec3(0.08, 0.03, 0.06);

      varying vec3 pposition;
      varying float psize;
      varying float palpha;
      varying float pdist;

      //varying mat3 rotMat;
      varying vec3 normX;
      varying vec3 normY;
      varying vec3 normZ;
      varying vec3 normal;

      varying float diffuse;
      varying float specular;
      varying float rstop;
      varying float distancefade;

      float ellipse(vec2 p, vec2 o, vec2 r) {
          vec2 lp = (p - o) / r;
          return length(lp) - 1.0;
      }

      void main(void) {
          vec3 p = vec3(gl_PointCoord - vec2(0.5, 0.5), 0.0) * 2.0;
          vec3 d = vec3(0.0, 0.0, -1.0);
          float nd = normZ.z; //dot(-normZ, d);
          if(abs(nd) < 0.0001) discard;

          float np = dot(normZ, p);
          vec3 tp = p + d * np / nd;
          vec2 coord = vec2(dot(normX, tp), dot(normY, tp));

          //angle = 15 degree
          const float flwrsn = 0.258819045102521;
          const float flwrcs = 0.965925826289068;
          mat2 flwrm = mat2(flwrcs, -flwrsn, flwrsn, flwrcs);
          vec2 flwrp = vec2(abs(coord.x), coord.y) * flwrm;

          float r;
          if(flwrp.x < 0.0) {
              r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.36, 0.96) * 0.5);
          }
          else {
              r = ellipse(flwrp, vec2(0.065, 0.024) * 0.5, vec2(0.58, 0.96) * 0.5);
          }

          if(r > rstop) discard;

          vec3 col = mix(vec3(1.0, 0.8, 0.75), vec3(1.0, 0.9, 0.87), r);
          float grady = mix(0.0, 1.0, pow(coord.y * 0.5 + 0.5, 0.35));
          col *= vec3(1.0, grady, grady);
          col *= mix(0.8, 1.0, pow(abs(coord.x), 0.3));
          col = col * diffuse + specular;

          col = mix(fadeCol, col, distancefade);

          float alpha = (rstop > 0.001)? (0.5 - r / (rstop * 2.0)) : 1.0;
          alpha = smoothstep(0.0, 1.0, alpha) * palpha;

          gl_FragColor = vec4(col * 0.5, alpha);
      }
    </script>
    <!-- effects -->
    <script id="fx_common_vsh" type="x-shader/x_vertex">
      uniform vec3 uResolution;
      attribute vec2 aPosition;

      varying vec2 texCoord;
      varying vec2 screenCoord;

      void main(void) {
          gl_Position = vec4(aPosition, 0.0, 1.0);
          texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);
          screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);
      }
    </script>
    <script id="bg_fsh" type="x-shader/x_fragment">
      #ifdef GL_ES
      //precision mediump float;
      precision highp float;
      #endif

      uniform vec2 uTimes;

      varying vec2 texCoord;
      varying vec2 screenCoord;

      void main(void) {
          vec3 col;
          float c;
          vec2 tmpv = texCoord * vec2(0.8, 1.0) - vec2(0.95, 1.0);
          c = exp(-pow(length(tmpv) * 1.8, 2.0));
          col = mix(vec3(0.02, 0.0, 0.03), vec3(0.96, 0.98, 1.0) * 1.5, c);
          gl_FragColor = vec4(col * 0.5, 1.0);
      }
    </script>
    <script id="fx_brightbuf_fsh" type="x-shader/x_fragment">
      #ifdef GL_ES
      //precision mediump float;
      precision highp float;
      #endif
      uniform sampler2D uSrc;
      uniform vec2 uDelta;

      varying vec2 texCoord;
      varying vec2 screenCoord;

      void main(void) {
          vec4 col = texture2D(uSrc, texCoord);
          gl_FragColor = vec4(col.rgb * 2.0 - vec3(0.5), 1.0);
      }
    </script>
    <script id="fx_dirblur_r4_fsh" type="x-shader/x_fragment">
      #ifdef GL_ES
      //precision mediump float;
      precision highp float;
      #endif
      uniform sampler2D uSrc;
      uniform vec2 uDelta;
      uniform vec4 uBlurDir; //dir(x, y), stride(z, w)

      varying vec2 texCoord;
      varying vec2 screenCoord;

      void main(void) {
          vec4 col = texture2D(uSrc, texCoord);
          col = col + texture2D(uSrc, texCoord + uBlurDir.xy * uDelta);
          col = col + texture2D(uSrc, texCoord - uBlurDir.xy * uDelta);
          col = col + texture2D(uSrc, texCoord + (uBlurDir.xy + uBlurDir.zw) * uDelta);
          col = col + texture2D(uSrc, texCoord - (uBlurDir.xy + uBlurDir.zw) * uDelta);
          gl_FragColor = col / 5.0;
      }
    </script>
    <!-- effect fragment shader template -->
    <script id="fx_common_fsh" type="x-shader/x_fragment">
      #ifdef GL_ES
      //precision mediump float;
      precision highp float;
      #endif
      uniform sampler2D uSrc;
      uniform vec2 uDelta;

      varying vec2 texCoord;
      varying vec2 screenCoord;

      void main(void) {
          gl_FragColor = texture2D(uSrc, texCoord);
      }
    </script>
    <!-- post processing -->
    <script id="pp_final_vsh" type="x-shader/x_vertex">
      uniform vec3 uResolution;
      attribute vec2 aPosition;
      varying vec2 texCoord;
      varying vec2 screenCoord;
      void main(void) {
          gl_Position = vec4(aPosition, 0.0, 1.0);
          texCoord = aPosition.xy * 0.5 + vec2(0.5, 0.5);
          screenCoord = aPosition.xy * vec2(uResolution.z, 1.0);
      }
    </script>
    <script id="pp_final_fsh" type="x-shader/x_fragment">
      #ifdef GL_ES
      //precision mediump float;
      precision highp float;
      #endif
      uniform sampler2D uSrc;
      uniform sampler2D uBloom;
      uniform vec2 uDelta;
      varying vec2 texCoord;
      varying vec2 screenCoord;
      void main(void) {
          vec4 srccol = texture2D(uSrc, texCoord) * 2.0;
          vec4 bloomcol = texture2D(uBloom, texCoord);
          vec4 col;
          col = srccol + bloomcol * (vec4(1.0) + srccol);
          col *= smoothstep(1.0, 0.0, pow(length((texCoord - vec2(0.5)) * 2.0), 1.2) * 0.5);
          col = pow(col, vec4(0.45454545454545)); //(1.0 / 2.2)

          gl_FragColor = vec4(col.rgb, 1.0);
          gl_FragColor.a = 1.0;
      }
    </script>
    <!-- partial -->
    <script src="sakura/script.js"></script>

    <script src="title/js/index.js"></script>

    <script>
      $("#control_button").hide();
      $("#control_effect").hover(
        function () {
          $("#control_button").show();
        },
        function () {
          $("#control_button").hide();
        }
      );
    </script>

    <!-- 随机轮播 -->
    <script>
      var image_shuffle = [];
      function randomNum() {
        //生成随机数 1 - picnum
        var num = parseInt(Math.ceil(Math.random() * picnum));
        if (image_shuffle.indexOf(num) == -1) {
          //去重
          image_shuffle.push(num);
        }
        if (image_shuffle.length < picnum / 4) {
          //生成picnum/4位随机数，这里可以配置生成几位
          randomNum();
        }
      }
      randomNum();
      var data = "<ul class='crosscover-list'>";
      for (i = 0; i < image_shuffle.length; i++) {
        data =
          data +
          "<li><img src='" +
          full_img_group[Number(image_shuffle[i]) - 1] +
          "' style='width:100%; height:auto;' alt='image" +
          i +
          "'></li>";
      }
      data = data + "</ul>";
      document.getElementById("shuffle").innerHTML = data;
    </script>

    <!-- 轮播的效果插件 Effect plug-in for carousel effect -->
    <script src="js/jquery-2.1.1.min.js"></script>
    <script src="js/crosscover.min.js"></script>
    <script type="text/javascript">
      $(".crosscover").crosscover({
        animateInClass: "bounce",
        animateOutClass: "flash",
        interval: 1000 * 5, // 1000ms * 60 * 10，十分钟自动切换
        startIndex: 0,
        autoPlay: true,
        controller: true,
        controllerClass: "crosscover-controller",
        prevClass: "crosscover-prev",
        nextClass: "crosscover-next",
        playerClass: "crosscover-player",
        playerActiveClass: "is-playing",
        playerInnerHtml: '<span class="crosscover-icon-player"></span>',
        prevInnerHtml: '<span class="crosscover-icon-prev"></span>',
        nextInnerHtml: '<span class="crosscover-icon-next"></span>',
      });
    </script>

    <script>
      document.getElementById("sbtn").onclick = () => {
        document.getElementById("shuffle").style.display = "none";
      };
    </script>

    <!-- 落樱效果的js -->
    <script>
      var RENDERER = {
        INIT_CHERRY_BLOSSOM_COUNT: 1,
        MAX_ADDING_INTERVAL: 400,

        init: function () {
          this.setParameters();
          this.reconstructMethods();
          this.createCherries();
          this.render();
        },
        setParameters: function () {
          this.$container = $("#jsi-cherry-container");
          this.width = this.$container.width();
          this.height = this.$container.height();
          this.context = $("<canvas />")
            .attr({ width: this.width, height: this.height })
            .appendTo(this.$container)
            .get(0)
            .getContext("2d");
          this.cherries = [];
          this.maxAddingInterval = Math.round(
            (this.MAX_ADDING_INTERVAL * 1000) / this.width
          );
          this.addingInterval = this.maxAddingInterval;
        },
        reconstructMethods: function () {
          this.render = this.render.bind(this);
        },
        createCherries: function () {
          for (
            var i = 0,
              length = Math.round(
                (this.INIT_CHERRY_BLOSSOM_COUNT * this.width) / 1000
              );
            i < length;
            i++
          ) {
            this.cherries.push(new CHERRY_BLOSSOM(this, true));
          }
        },
        render: function () {
          requestAnimationFrame(this.render);
          this.context.clearRect(0, 0, this.width, this.height);

          this.cherries.sort(function (cherry1, cherry2) {
            return cherry1.z - cherry2.z;
          });
          for (var i = this.cherries.length - 1; i >= 0; i--) {
            if (!this.cherries[i].render(this.context)) {
              this.cherries.splice(i, 1);
            }
          }
          if (--this.addingInterval == 0) {
            this.addingInterval = this.maxAddingInterval;
            this.cherries.push(new CHERRY_BLOSSOM(this, false));
          }
        },
      };
      var CHERRY_BLOSSOM = function (renderer, isRandom) {
        this.renderer = renderer;
        this.init(isRandom);
      };
      CHERRY_BLOSSOM.prototype = {
        FOCUS_POSITION: 300,
        FAR_LIMIT: 600,
        MAX_RIPPLE_COUNT: 100,
        RIPPLE_RADIUS: 100,
        SURFACE_RATE: 0.5,
        SINK_OFFSET: 20,

        init: function (isRandom) {
          this.x = this.getRandomValue(
            -this.renderer.width,
            this.renderer.width
          );
          this.y = isRandom
            ? this.getRandomValue(0, this.renderer.height)
            : this.renderer.height * 1.5;
          this.z = this.getRandomValue(0, this.FAR_LIMIT);
          this.vx = this.getRandomValue(-2, 2);
          this.vy = -2;
          this.theta = this.getRandomValue(0, Math.PI * 2);
          this.phi = this.getRandomValue(0, Math.PI * 2);
          this.psi = 0;
          this.dpsi = this.getRandomValue(Math.PI / 600, Math.PI / 300);
          this.opacity = 0;
          this.endTheta = false;
          this.endPhi = false;
          this.rippleCount = 0;

          var axis = this.getAxis(),
            theta =
              this.theta +
              (Math.ceil(
                -(this.y + this.renderer.height * this.SURFACE_RATE) / this.vy
              ) *
                Math.PI) /
                500;
          theta %= Math.PI * 2;

          this.offsetY =
            40 * (theta <= Math.PI / 2 || theta >= (Math.PI * 3) / 2 ? -1 : 1);
          this.thresholdY =
            this.renderer.height / 2 +
            this.renderer.height * this.SURFACE_RATE * axis.rate;
          this.entityColor = this.renderer.context.createRadialGradient(
            0,
            40,
            0,
            0,
            40,
            80
          );
          this.entityColor.addColorStop(
            0,
            "hsl(330, 70%, " + 50 * (0.3 + axis.rate) + "%)"
          );
          this.entityColor.addColorStop(
            0.05,
            "hsl(330, 40%," + 55 * (0.3 + axis.rate) + "%)"
          );
          this.entityColor.addColorStop(
            1,
            "hsl(330, 20%, " + 70 * (0.3 + axis.rate) + "%)"
          );
          this.shadowColor = this.renderer.context.createRadialGradient(
            0,
            40,
            0,
            0,
            40,
            80
          );
          this.shadowColor.addColorStop(
            0,
            "hsl(330, 40%, " + 30 * (0.3 + axis.rate) + "%)"
          );
          this.shadowColor.addColorStop(
            0.05,
            "hsl(330, 40%," + 30 * (0.3 + axis.rate) + "%)"
          );
          this.shadowColor.addColorStop(
            1,
            "hsl(330, 20%, " + 40 * (0.3 + axis.rate) + "%)"
          );
        },
        getRandomValue: function (min, max) {
          return min + (max - min) * Math.random();
        },
        getAxis: function () {
          var rate = this.FOCUS_POSITION / (this.z + this.FOCUS_POSITION),
            x = this.renderer.width / 2 + this.x * rate,
            y = this.renderer.height / 2 - this.y * rate;
          return { rate: rate, x: x, y: y };
        },
        renderCherry: function (context, axis) {
          context.beginPath();
          context.moveTo(0, 40);
          context.bezierCurveTo(-60, 20, -10, -60, 0, -20);
          context.bezierCurveTo(10, -60, 60, 20, 0, 40);
          context.fill();

          for (var i = -4; i < 4; i++) {
            context.beginPath();
            context.moveTo(0, 40);
            context.quadraticCurveTo(i * 12, 10, i * 4, -24 + Math.abs(i) * 2);
            context.stroke();
          }
        },
        render: function (context) {
          var axis = this.getAxis();

          if (
            axis.y == this.thresholdY &&
            this.rippleCount < this.MAX_RIPPLE_COUNT
          ) {
            context.save();
            context.lineWidth = 2;
            context.strokeStyle =
              "hsla(0, 0%, 100%, " +
              (this.MAX_RIPPLE_COUNT - this.rippleCount) /
                this.MAX_RIPPLE_COUNT +
              ")";
            context.translate(
              axis.x +
                this.offsetY * axis.rate * (this.theta <= Math.PI ? -1 : 1),
              axis.y
            );
            context.scale(1, 0.3);
            context.beginPath();
            context.arc(
              0,
              0,
              (this.rippleCount / this.MAX_RIPPLE_COUNT) *
                this.RIPPLE_RADIUS *
                axis.rate,
              0,
              Math.PI * 2,
              false
            );
            context.stroke();
            context.restore();
            this.rippleCount++;
          }
          if (axis.y < this.thresholdY || !this.endTheta || !this.endPhi) {
            if (this.y <= 0) {
              this.opacity = Math.min(this.opacity + 0.01, 1);
            }
            context.save();
            context.globalAlpha = this.opacity;
            context.fillStyle = this.shadowColor;
            context.strokeStyle =
              "hsl(330, 30%," + 40 * (0.3 + axis.rate) + "%)";
            context.translate(
              axis.x,
              Math.max(axis.y, this.thresholdY + this.thresholdY - axis.y)
            );
            context.rotate(Math.PI - this.theta);
            context.scale(axis.rate * -Math.sin(this.phi), axis.rate);
            context.translate(0, this.offsetY);
            this.renderCherry(context, axis);
            context.restore();
          }
          context.save();
          context.fillStyle = this.entityColor;
          context.strokeStyle = "hsl(330, 40%," + 70 * (0.3 + axis.rate) + "%)";
          context.translate(
            axis.x,
            axis.y + Math.abs(this.SINK_OFFSET * Math.sin(this.psi) * axis.rate)
          );
          context.rotate(this.theta);
          context.scale(axis.rate * Math.sin(this.phi), axis.rate);
          context.translate(0, this.offsetY);
          this.renderCherry(context, axis);
          context.restore();

          if (this.y <= -this.renderer.height / 4) {
            if (!this.endTheta) {
              for (
                var theta = Math.PI / 2, end = (Math.PI * 3) / 2;
                theta <= end;
                theta += Math.PI
              ) {
                if (this.theta < theta && this.theta + Math.PI / 200 > theta) {
                  this.theta = theta;
                  this.endTheta = true;
                  break;
                }
              }
            }
            if (!this.endPhi) {
              for (
                var phi = Math.PI / 8, end = (Math.PI * 7) / 8;
                phi <= end;
                phi += (Math.PI * 3) / 4
              ) {
                if (this.phi < phi && this.phi + Math.PI / 200 > phi) {
                  this.phi = Math.PI / 8;
                  this.endPhi = true;
                  break;
                }
              }
            }
          }
          if (!this.endTheta) {
            if (axis.y == this.thresholdY) {
              this.theta +=
                (Math.PI / 200) *
                (this.theta < Math.PI / 2 ||
                (this.theta >= Math.PI && this.theta < (Math.PI * 3) / 2)
                  ? 1
                  : -1);
            } else {
              this.theta += Math.PI / 500;
            }
            this.theta %= Math.PI * 2;
          }
          if (this.endPhi) {
            if (this.rippleCount == this.MAX_RIPPLE_COUNT) {
              this.psi += this.dpsi;
              this.psi %= Math.PI * 2;
            }
          } else {
            this.phi += Math.PI / (axis.y == this.thresholdY ? 200 : 500);
            this.phi %= Math.PI;
          }
          if (this.y <= -this.renderer.height * this.SURFACE_RATE) {
            this.x += 2;
            this.y = -this.renderer.height * this.SURFACE_RATE;
          } else {
            this.x += this.vx;
            this.y += this.vy;
          }
          return (
            this.z > -this.FOCUS_POSITION &&
            this.z < this.FAR_LIMIT &&
            this.x < this.renderer.width * 1.5
          );
        },
      };
      $(function () {
        RENDERER.init();
      });
    </script>
  </body>
</html>
